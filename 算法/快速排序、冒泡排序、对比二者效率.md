# 快速排序和冒泡排序，二者效率比较

## 快速排序

```javascript
let arr1 = [1, 23, 4, 2, 5, 6, 90, 0, 2, 55, 1.3]

function quickSort(arr) {
    // 交换元素位置
    function swap(arr, i, k) {
        var temp = arr[i];
        arr[i] = arr[k];
        arr[k] = temp;
    }
    // 数组分区，左小右大
    function partition(arr, left, right) {
        var storeIndex = left;
        var pivot = arr[right]; // 直接选最右边的元素为基准元素
        for (var i = left; i < right; i++) {
            if (arr[i] < pivot) {
                swap(arr, storeIndex, i);
                storeIndex++; // 交换位置后，storeIndex 自增 1，代表下一个可能要交换的位置
            }
        }
        swap(arr, right, storeIndex); // 将基准元素放置到最后的正确位置上
        return storeIndex;
    }
    function sort(arr, left, right) {
        if (left > right) {
            return;
        }
        var storeIndex = partition(arr, left, right);
        sort(arr, left, storeIndex - 1);
        sort(arr, storeIndex + 1, right);
    }
    sort(arr, 0, arr.length - 1);
    return arr;
}

quickSort(arr1) //[0, 1, 1.3, 2, 2, 4, 5, 23, 55, 90]
```

## 冒泡排序

>考虑一个优化情况：当一次循环后就实现了排序，但后续循环依然会执行，如何避免
>>加入一个布尔值判断是否当前循环结束没有发生交换，是的话则退出循环

```javascript
function bubbleSort(arr) {
    // 数组元素两两交换，每次循环需要length-1轮
    let len = arr.length - 1;
    //外层循环数组元素，内层交换位置
    for (let i = 0; i < len; i++) {
        // 每轮排序中:需要比较的元素个数比上一轮少一个（每一轮的最后一个值一定是最大的）
        let done=true;
        for (let j = 0; j < len - i; j++) {
            if (arr[j] > arr[j + 1]) {
                // 辅助交换位置的中间变量
                let temp = arr[j + 1];
                arr[j + 1] = arr[j];
                arr[j] = temp;
                done=false;
            }
        }
        if(done){
            break;
        }
    }
    return arr;
}
```

## 二者效率比较

>为方便看出效果，编写函数生成数组
createArr();
compare();

```javascript
// 生成数组
function createArr(count){
    let arr=[];
    for(let i=0;i<count;i++){
        arr[i]=Math.floor(Math.random()*(count+1));
        arr.push(arr[i]);
    }
    return arr;
}

//计算运行时间
function compare(func,count){
    let start,stop;
    let arr=createArr(count);
    // start=Date.now();
    start=window.performance.now();
    func(arr);
    // stop=Date.now();
    stop=window.performance.now();
    result=stop-start;
    console.log(result);
}

compare(bubbleSort,100);//      2.299999992828816
compare(quickSort,100);//       0.4000000044470653
compare(bubbleSort,1000);//     14.500000004773028
compare(quickSort,1000);//      2.5000000023283064
compare(bubbleSort,10000);//    888.3000000059837
compare(quickSort,10000);//     4.100000005564652
// 单位毫秒
// performance.now提供亚毫秒级的时间精度
//具体计算时间受硬件影响
//但总体上能看出冒泡排序明显与快速排序有很大差距
```