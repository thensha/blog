# HashTable基本使用思路

>*本文是一个基本的思路整理，后续会补充代码实践*

>散列：无序
>映射型数据结构：数据结构不是以键值对形式存储，而是根据键值生成一个散列值，然后将元素值存在对应的一个地址上，查找时根据散列值去查找地址，故无需遍历所有数据

## 基本概念

1. 是一种无序数据结构
2. 目的在于尽可能快的找到一个值
3. 相比于字典的优势：不需要遍历整个数据结构（字典使用对象实例，散列表使用数组）
4. 核心：散列函数（根据给定的键值返回其在表中的地址）

---
    散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key 对应一个存储位置f (key)。查找时，根据这个确定的对应关系找到给定值key 的映射f (key) ，若查找集合中存在这个记录，则必定在f (key) 的位置上。这里我们把这种对应关系f 称为散列函数， 又称为哈希(Hash) 函数。按这个思想，采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表(Hash table)。 那么关键字对应的记录存储位置我们称为散列地址。

    整个散列过程其实就是两步。
    (1) 在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。
    (2) 当查找记录时，我们通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。由于存取用的是同一个散列函数， 因此结果当然也是相同的。

    所以说，散列技术既是一种存储方法，也是一种查找方法。然而它与线性表、树、图等结构不同的是，前面几种结构，数据元素之间都存在某种逻辑关系，可以用连线图示表示出来，而散列技术的记录之间不存在什么逻辑关系，它只与关键字有关联。因此，散列主要是面向查找的存储结构

    原文：https://blog.csdn.net/u012441545/article/details/52139229
---

## 散列函数

1.lose lose

    var loseloseHashTable = function(key) {
    var hash = 0;
    for(var i = 0; i < key.length; i++) {
        hash += key.charCodeAt(i);
    }
    return hash % 37; //这里只是为了得到比较小的数值，随便除了一个数
    }

>由于仅仅是根据ASCII作加法，故会出现散列值冲突的情况，此时有两种优化思路
>>1. 分离链接：为散列表的每个位置创建一个链表，并将元素存储在里面，但需要额外的存储空间
>>2. 线性探查：当尝试新增一个元素时，如果该位置被占用则尝试index+1的位置，逐级递增

>但以上方法更像是对选择了错误散列函数打的补丁，所以根本上应该选择更低冲突率的散列函数

2.djb2

    var djb2HashCode = function(key) {
    var hash = 5381; //初始化一个hash变量并赋值为一个质数5381
    for(var i = 0; i < key.length; i++) { //遍历
        hash = hash * 33 + key.charCodeAt(i);
    }
    return hash % 1013;
    }

除此之外，还有bkdr、sdbm散列函数，以后如果有需要再作了解

参考各种散列函数效率对比：https://cloud.tencent.com/developer/article/1019599