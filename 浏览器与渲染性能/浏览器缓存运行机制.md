# HTTP协议下的缓存运行机制 ('GET')

>设置文件缓存的两种方式：服务器内设置响应头文件；用manifest文件设置缓存列表

>强缓存与协商缓存
>>1.强缓存：又称本地缓存，主要是采用响应头中的 Cache-Control 和 Expires 两个字段进行控制
>>2.协商缓存：是一个缓存验证的机制，即本地缓存失效，就需要进行服务器再验证，如果服务器文件未更新，则返回304继续使用缓存文件

## 一、根据服务器响应信息决定如何处理缓存

    常用返回头信息有：
    1. Expires：（接收服务器端的GMT时间字符串，http1.0时代产物，用于表示文件有效的绝对日期；但由于存在客户端和服务器时差问题会有bug，仅建议在长时间缓存情况下使用；设为负数时与no-cache功能相同）
    2. Cache-Control（http1.1时代产物，用于定义缓存策略）
    3. Last-Modified（对应请求为If-Modified-Since；日期验证——向缓存信息中加入服务器上该文件最后一次修改的时间，用于验证是否更新，若无更新则不在响应头上再次发送）
    4. E-Tag（对应请求为If-None-Match；内容验证——是一串由服务器随机生成的散列值，通常使用md5或SHA1值计算文件唯一值（sha-1在抗强攻击强分析上安全度更高，相应的运行速度会慢一点），仅当文件内容变化时更新，不论是否更改都会随响应头一起发送）

---

    注：expires 和 max-age同时存在时，max-age优先级高；
       Last-Modified 和 ETag同时存在时，ETag优先级高；
    原因：1. Last-Modified 是GMT时间，单位最小是秒，无法进行毫秒级的文件更新
         2. 存在周期性更新的资源（Last-modified时间会变），但内容不一定更改，此时无需重复下载新资源

### 如果允许缓存，则对资源进行缓存，并记录响应头信息用于下次请求时作为请求头

    例如：Cache-Control 常用值有：
    1. max-age=秒（缓存可用时长，如果设为0则表示每次都需要协商，同no-cache的功能）
    2. no-cache（不允许直接使用强缓存，每次都需要协商）
    3. no-store（不允许使用缓存，强制必须每次获取新资源）
    4. public（允许任何用户使用缓存，包括公共缓存服务器）
    5. private（禁止中间服务器缓存，如浏览器可以保存带有用户个人信息的html网页，但cdn不可以）

## 二、如何在缓存未过期时更新用户的缓存

>情况描述：

    浏览器缓存响应后，缓存的版本将一直使用到过期（由 max-age 或 expires 决定），或一直使用到由于某种其他原因从缓存中删除，例如用户清除了浏览器缓存。因此，构建网页时，不同的用户可能最终使用的是文件的不同版本；刚获取了资源的用户将使用新版本的响应，而缓存了早期（但仍有效）副本的用户将使用旧版本的响应。

>解决办法：

    服务器端修改文件地址：通过在文件名中嵌入文件的指纹或版本号来实现。例如 style.x234dff.css

## 三、优化缓存策略：根据文件类型设置Cache-Control

|文件类型|缓存层级|原因|
|:-:|:-|:-|
|HTML|Cache-Control: no-cache,must-revalidate|绝大部分的html文件都不建议缓存|
|JS|Cache-Control:private,max-age=86400（24小时）|根据实际判断设置|
|CSS|Cache-Control:max-age=31536000（一年）|根据实际判断设置|
|img/fonts|Cache-Control:max-age=86400|根据实际判断设置|

## 四、用户行为对浏览器缓存策略的影响

>此处意为：用户的何种行为会打乱强缓存和协商缓存的运行机制，导致直接性的重新获取服务器资源

    不影响的行为：地址栏访问网站、页面链接跳转、新开窗口、前进后退
    影响的行为：人为F5刷新页面会导致强缓存失效，进行一次协商缓存；
              Ctrl+F5强制刷新会导致一次强制获取资源更新

## 五、无法缓存的文件

>即使设置了缓存策略也不会进行缓存的文件

    动态认证的文件，如需要cookie验证，输入验证码等产生的文件；
    POST请求文件不能被缓存；
